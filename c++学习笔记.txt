#include<iostream>   和 #include"iostream" 的区别
	两者唯一的区别是编译器将在什么地方查找值文件，如果头文件名是用“”引起来的，则编译器先在包含此指令的源
		文件所在的目录搜索头文件。如果头文件未找到，编译器再搜索存储标准头文件的目录；
	如果用<>括起来的，则编译器只会搜索包含标准头文件的目录。	
	
名称空间:
	名称空间是一种机制，它可以将无意中使用重命名的风险降至最低，其方法是将一组给定的名称(如标准库中的名称)
		与一种姓(family name) 关联起来，这种姓就是名称空间名称。
	标准库工具定义在std名称空间内。
	
分析using std:cout的含义:
	std   -- 标准库名称空间   
	cout -- 实体名称
	::    -- 作用域解析运算符
	using -- 标准库中 cout 和 endl 的全名是 std::cout 和 std:endl， 在程序中使用全名会使代码看起来有点混乱，
				所以最好使用不由名称空间名称 std 限定的简化名， using声明实现了这种想法。using声明告诉编译器，
				要在不指定名称空间的情况下使用名称空间 std 中的名称 cout 和 endl。编译器假定，在第一个using
				声明之后，只要使用名称cout，就表示 std::cout。
	cout:表示对应命令行的标准输出流；
	endl:表示换行符;
	cin：表示标准输入流;
	setw:表示设置输出宽度;
	setiosflags: 表示设置对齐方式;
	
std::cout<<std::endl;
	运算符<<表明，该运算符的右边的内容将发送到输出了cout。<<运算符"指出"数据流动的方向。
	<<在C++中，有两个运算含义：
	1.重载输出流运算符，一般运用格式为：cout<<x;其中cout为流文件，如显示设备，输出设备，或者数据文件等。
	2.数据移位运算符，左移几位，如：x=i<<4;就是将i的值左移4位（放大2的4此方）后，赋给x，若i=2,则X=32。
	
typeof关键字能够为现有的类型定义自己的类型名称:
		如: typeof long int BigOnes;
			BigOnes myNumber  等同于   long int myNumber
		c++ 11引入了另一种语法，用using定义别名,语法规则:
		using BigOnes = long int;
		
		
一、static_cast关键字（编译时类型检查）
用法：static_cast < type-id > ( expression )，该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，它主要有如下几种用法：
（1）用于基本数据类型之间的转换，如把int转换为char，把int转换成enum，但这种转换的安全性需要开发者自己保证（这可以理解为保证数据的精度，即程序员能不能保证自己想要的程序安全），
		如在把int转换为char时，如果char没有足够的比特位来存放int的值（int>127或int<-127时），那么static_cast所做的只是简单的截断，及简单地把int的低8位复制到char的8位中，并直接抛弃高位。
（2）把空指针转换成目标类型的空指针
（3）把任何类型的表达式类型转换成void类型
（4）用于类层次结构中父类和子类之间指针和引用的转换。
	对于以上第（4）点，存在两种形式的转换，即上行转换（子类到父类）和下行转换（父类到子类）。对于static_cast，上行转换时安全的，而下行转换时不安全的，为什么呢？
	因为static_cast的转换时粗暴的，它仅根据类型转换语句中提供的信息（尖括号中的类型）来进行转换，这种转换方式对于上行转换，由于子类总是包含父类的所有数据成员和函数成员，
	因此从子类转换到父类的指针对象可以没有任何顾虑的访问其（指父类）的成员。而对于下行转换为什么不安全，是因为static_cast只是在编译时进行类型坚持，没有运行时的类型检查，
	具体原理在dynamic_cast中说明。
二、dynamic_cast关键字（运行时类型检查）
用法：同static_cast
dynamic_cast主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下行转换的安全性，何为安全性？即转换成功就返回转换后的正确类型指针，
	如果转换失败，则返回NULL，之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。
	对于上行转换，dynamic_cast和static_cast是一样的。
	
typeid是C++的关键字之一，等同于sizeof这类的操作符。typeid操作符的返回结果是名为type_info的标准库类型的对象的引用。

namespace声明一个名称空间

结构名与数组名不一样，结构名并不是结构的地址
在C中，->是获得指针指向的复杂类型目标的成员的操作符。例如声明了一个结构体变量A，同时声明了一个A的指针pA，那么要获得结构体变量A的成员n，就可以写pA->n来完成。


初始化对象的方法:
	CBox *box2 = new CBox(8.0, 5.0, 1.0);
	CBox box3(5.0, 6.0, 7.0);
	
class CExample {
	public:
    int a;
    float b;
    //构造函数初始化列表
    CExample(): a(0),b(8.8)
    {}
    //构造函数内部赋值
    CExample()
    {
        a=0;
        b=8.8;
    }
};

引用可以理解为地址不可改变的指针:


左值与右值的理解:
	对于lvalue的通俗描述，是“具有确定地址的非临时对象”，而不满足lvalue定义的值均被认为是rvalue。换句话说，C++程序里面出现的值，非左即右。
		下面我们分析一下这三个存放数据的区域里面可以被使用的值的情况：
	堆

	堆的空间上的变量完全由程序员申请和管理的，所以它们都有明确的地址，是可以放心使用的左值。

	静态数据区

	对于静态数据区，尽管存放的位置是固定的，但里面的数据并不能认为都是左值。主要是因为里面有“字面值”，包括const所实现的常量，即静态存储而不能被修改的值。

	函数栈

	当函数调用发生的时候，系统会创建函数栈，保留上下文，函数调用结束的时候，函数栈内的变量会被销毁。函数体里面定义的变量是左值，而临时变量是右值。


this是指针变量

const int *p; // const修饰的是*p，因此*p是常量不能改变，但可以改变p的指向；
int const* p; // 同上，主要是看const与*的前后关系；
int* const p; // const修饰的是p，因此p的指向是常量不能改变，但*p可以改变；定义的时候必须初始化
const int const *p; // 两个const既修饰了*p也修饰了p，因此*p与p都是常量不能改变；


函数重载:
	1.参数缺省模式
    void fun(int i = 0 int n = 0)
	是 void fun()  和 void fun(int i, int n)的重载不传值时去默认值


explicit Person() {}  取消隐式转换
运算符重载 operator
++c;  // 等价于下一行
    c.operator++();
    
c++;  // 等价于下一行 
    c.operator++(0);
	
operator++(int) 匹配i++
operator++() 匹配++i

左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).
在 c 语言中，通常来说有名字的变量就是左值(如上面例子中的 a, b)，而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值，如上的 3 + 4， a + b 等。我们暂且可以认为：左值就是在程序中能够寻值的东西，右值就是没法取到它的地址的东西(不完全准确)，但如上概念到了 c++ 中，就变得稍有不同。具体来说，在 c++ 中，每一个表达式都会产生一个左值，或者右值，相应的，该表达式也就被称作“左值表达式"， "右值表达式"。对于基本数据类型来说(primitive types)，左值右值的概念和 c 没有太多不同，不同的地方在于自定义的类型，而且这种不同比较容易让人混淆:

1) 对于基础类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰(cv-qualitification ignored)

2) 对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。







继承:
	子类访问父类的protected修饰的变量或方法时必须定义public方法来访问

	virtual  虚基类
	虚函数:系统在执行到有关键字virtual修饰的函数时，就会自动判断是哪个对象调用了它，然后调用该对象的同名函数。
	
	
字符串:
	cin.getline()实际上有三个参数，cin.getline(接受字符串是m,接受个数5,结束字符
	cin.get(字符数M名,接收字符数目)用斫邮找恍凶址串,可以接收空格
	strcat()
		函数：连接字符串
	strcpy(s1,s2);
		复制函数
		strcpy函数的意思是：把字符串s2中的内容copy到s1中，连字符串结束标志也一起copy.
		这样s1在内存中的存放为：ch\0;
		在cout<<s1<<endl时，结果为ch;事实上，在内存里面是这样的存储结构：ch\0na
		如果说s1的长度是6，那是错误的.你没有弄清strlen与sizeof的意思。
		strlen函数的意思是测试字符串的字符长度，不含字符串结束标志的。
		sizeof是个运算符，它的结果是字符串在内存中的所占字节大小，它要把\0算进去的。
		
		char * strcpy(char *dst,const char *src)   
		{
			if((dst==NULL)||(src==NULL))
				 
				   return NULL; 
		 
			char *ret = dst; //[1]
		 
			while ((*dst++=*src++)!='\0'); //[2]
		 
			return ret;//[3]
		}
		
		strcmp 比较函数
			C/C++函数，比较两个字符串字母的ASCII值，顺序比较
			设这两个字符串为str1，str2，
			若str1=str2，则返回零；
			若str1<str2，则返回负数；
			若str1>str2，则返回正数。
		
		strupr 将小写字母转化成大写字母
		
		strlowr 将大写字母转化成小写字母
		
		strlen  得到字符串的长度











